# 🛠️ Agent 개발 가이드

## ⚠️ 핵심 주의사항

### 1. 상태(State) 관리 규칙

#### ✅ 올바른 방식
```python
def my_agent_node(state):
    """Agent는 dict를 반환해야 함"""
    
    # state에서 읽기
    user_query = state.get("user_query", "")
    constraints = state.get("constraints", {})
    
    # 처리 로직
    result = do_something(user_query, constraints)
    
    # dict 반환 (업데이트할 키만)
    return {
        "my_result": result,
        "logs": [f"[{datetime.now()}] my_agent: 완료"]
    }
```

#### ❌ 잘못된 방식
```python
def my_agent_node(state):
    # 잘못: state를 직접 수정
    state["my_result"] = result  # ❌
    state.my_result = result     # ❌
    
    # 잘못: state 객체 반환
    return state  # ❌
```

---

### 2. TypedDict vs Pydantic 이슈

현재 `AgentState`는 **TypedDict**입니다.

```python
# ✅ 올바른 접근
value = state.get("key")
value = state["key"]

# ❌ 잘못된 접근
value = state.key  # AttributeError!
```

#### Pydantic 모델 사용 시
```python
from contracts import ContextJSON

def context_agent_node(state):
    # Pydantic 모델 생성
    context = ContextJSON(...)
    
    # dict로 변환하여 반환
    return {
        "context_json": context.dict()  # ✅
        # "context_json": context       # ❌ Pydantic 객체 그대로는 안됨
    }
```

---

### 3. 병렬 처리 규칙

#### logs 필드는 특별함
```python
# graph.py에서 정의
class AgentState(TypedDict):
    logs: Annotated[list[str], operator.add]  # 병렬 처리용
```

```python
# ✅ 올바른 로그 추가
return {
    "logs": ["새 로그 1", "새 로그 2"]  # 자동으로 기존 logs에 추가됨
}

# ❌ 잘못된 방식
logs = state.get("logs", [])
logs.append("새 로그")  # 병렬 실행 시 중복/누락 가능
return {"logs": logs}
```

#### 다른 필드는 덮어쓰기
```python
# context_json은 마지막 값으로 덮어씀
return {
    "context_json": new_context  # 이전 값 무시
}
```

---

### 4. 에러 처리

#### 각 Agent에서 방어 코드 작성
```python
def context_agent_node(state):
    try:
        constraints = state.get("constraints", {})
        
        # 필수 값 검증
        if not constraints.get("store_id"):
            logger.warning("store_id 누락")
            return {
                "context_json": None,
                "logs": ["[ERROR] store_id 필수"]
            }
        
        # 정상 처리
        context = _build_context_json(state)
        
        return {
            "context_json": context.dict(),
            "logs": [f"[{datetime.now()}] context_agent: 완료"]
        }
        
    except Exception as e:
        logger.error(f"Context Agent 오류: {e}")
        return {
            "context_json": None,
            "logs": [f"[ERROR] {str(e)}"]
        }
```

---

### 5. None 체크 필수

```python
def merge_supervisor_node(state):
    context = state.get("context_json")
    situation = state.get("situation_json")
    resource = state.get("resource_json")
    
    # ✅ None 체크
    if not context:
        logger.warning("Context 누락")
        # 기본값 사용 또는 에러 처리
    
    # ✅ 안전한 접근
    metrics = context.get("metrics", {}) if context else {}
    kpi = metrics.get("kpi", {})
```

---

### 6. 그래프 구조 수정 시

#### graph.py 수정
```python
# 새 노드 추가
def new_agent_node(state):
    return {"new_field": "value"}

def build_graph():
    g = StateGraph(AgentState)
    
    # 노드 등록
    g.add_node("new_agent", new_agent_node)
    
    # 엣지 연결
    g.add_edge("context_agent", "new_agent")
    g.add_edge("new_agent", "merge_supervisor")
    
    return g.compile()
```

#### AgentState에 필드 추가
```python
class AgentState(TypedDict):
    # 기존 필드
    user_query: str
    
    # 새 필드 추가
    new_field: str | None  # None 허용 타입
```

---

### 7. DB 연동 시 주의사항

```python
def context_agent_node(state):
    constraints = state.get("constraints", {})
    store_id = constraints.get("store_id")
    
    # ✅ DB 연결 관리
    try:
        conn = get_db_connection()
        
        # 쿼리 실행
        df = pd.read_sql(
            "SELECT * FROM store_metrics WHERE store_id = %s",
            conn,
            params=(store_id,)
        )
        
        # 데이터 처리
        result = process_dataframe(df)
        
        return {"context_json": result}
        
    except Exception as e:
        logger.error(f"DB 오류: {e}")
        return {
            "context_json": None,
            "logs": [f"[ERROR] DB 연결 실패: {str(e)}"]
        }
        
    finally:
        if conn:
            conn.close()  # 반드시 연결 종료
```

---

### 8. LLM 통합 시

```python
from langchain_google_genai import ChatGoogleGenerativeAI

def strategy_supervisor_node(state):
    user_query = state.get("user_query", "")
    
    # ✅ LLM 초기화 (캐싱 고려)
    llm = ChatGoogleGenerativeAI(
        model="gemini-2.0-flash-exp",
        temperature=0.7
    )
    
    # 프롬프트 구성
    prompt = f"""
    사용자 질문: {user_query}
    
    이 질문의 의도를 분석하세요.
    - strategy: 전략 수립
    - comparison: 비교 분석
    """
    
    try:
        response = llm.invoke(prompt)
        intent = response.content.strip()
        
        return {
            "intent": intent,
            "logs": [f"LLM 의도 분석: {intent}"]
        }
        
    except Exception as e:
        logger.error(f"LLM 오류: {e}")
        # 폴백: 규칙 기반
        intent = "strategy" if "전략" in user_query else "comparison"
        return {
            "intent": intent,
            "logs": [f"[FALLBACK] 규칙 기반 의도: {intent}"]
        }
```

---

### 9. 테스트 작성

```python
# tests/test_context_agent.py
import pytest

def test_context_agent_basic():
    """기본 동작 테스트"""
    state = {
        "user_query": "테스트",
        "constraints": {
            "store_id": "S123",
            "start_date": "2025-01-01",
            "end_date": "2025-01-31"
        },
        "logs": []
    }
    
    result = context_agent_node(state)
    
    # 검증
    assert result is not None
    assert "context_json" in result
    assert result["context_json"] is not None
    assert len(result["logs"]) > 0

def test_context_agent_missing_store_id():
    """store_id 누락 시 처리"""
    state = {
        "user_query": "테스트",
        "constraints": {},  # store_id 없음
        "logs": []
    }
    
    result = context_agent_node(state)
    
    # 에러 처리 확인
    assert "context_json" in result
    # 기본값 또는 None 반환 확인
```

---

### 10. 성능 최적화

#### 캐싱
```python
from functools import lru_cache

@lru_cache(maxsize=100)
def get_market_data(market_id: str):
    """시장 데이터 캐싱"""
    # DB 조회 (캐싱됨)
    return query_market_data(market_id)
```

#### 비동기 처리
```python
import asyncio

async def context_agent_node_async(state):
    """비동기 버전"""
    # 여러 DB 쿼리를 병렬로
    store_data, market_data = await asyncio.gather(
        fetch_store_data_async(store_id),
        fetch_market_data_async(market_id)
    )
    
    return {"context_json": combine(store_data, market_data)}
```

---

### 11. 로깅 Best Practices

```python
from loguru import logger

def my_agent_node(state):
    # 입력 로깅
    logger.info(f"Agent 시작: {state.get('user_query')}")
    
    # 중요 단계 로깅
    logger.debug(f"constraints: {state.get('constraints')}")
    
    # 경고
    if not some_condition:
        logger.warning("특정 조건 미충족")
    
    # 에러
    try:
        result = do_something()
    except Exception as e:
        logger.error(f"처리 실패: {e}", exc_info=True)
        raise
    
    # 완료 로깅
    logger.info("Agent 완료")
    
    return {"result": result}
```

---

### 12. 버전 관리

#### 스키마 버전
```python
class ContextJSON(BaseModel):
    # 버전 관리
    contract_version: str = Field("ctx.v1", description="스키마 버전")
    
    # 향후 ctx.v2로 업그레이드 시 호환성 유지
```

#### 하위 호환성
```python
def _build_context_json(state) -> ContextJSON:
    # v1, v2 모두 지원
    version = state.get("schema_version", "v1")
    
    if version == "v1":
        return _build_context_v1(state)
    elif version == "v2":
        return _build_context_v2(state)
    else:
        logger.warning(f"Unknown version: {version}, using v1")
        return _build_context_v1(state)
```

---

## 📋 체크리스트

Agent 개발/수정 시 확인사항:

- [ ] dict를 반환하는가? (state 객체 반환 금지)
- [ ] state는 `.get()` 또는 `[]`로 접근하는가?
- [ ] Pydantic 모델은 `.dict()`로 변환했는가?
- [ ] None 체크를 했는가?
- [ ] 에러 처리가 되어 있는가?
- [ ] 로그를 남기는가?
- [ ] 테스트 코드를 작성했는가?
- [ ] graph.py에 노드를 등록했는가?
- [ ] AgentState에 필요한 필드를 추가했는가?

---

## 🐛 디버깅 팁

### 1. 로그 레벨 조정
```python
# agents/__init__.py 또는 각 파일 상단
from loguru import logger
import sys

logger.remove()
logger.add(sys.stderr, level="DEBUG")  # 모든 로그 출력
```

### 2. State 출력
```python
def debug_node(state):
    """디버그용 노드"""
    print("="*60)
    print("현재 State:")
    print("="*60)
    for key, value in state.items():
        if isinstance(value, dict):
            print(f"{key}: [dict with {len(value)} keys]")
        elif isinstance(value, list):
            print(f"{key}: [list with {len(value)} items]")
        else:
            print(f"{key}: {value}")
    
    return {}  # 상태 변경 없음
```

### 3. Jupyter에서 단계별 실행
```python
# test_agents.ipynb 활용
state = create_test_state("테스트 질문")

# 단계별 실행
result1 = context_agent_node(state)
print(result1)

state.update(result1)
result2 = situation_agent_node(state)
print(result2)
```

---

## 📚 참고 문서

- [LangGraph 공식 문서](https://langchain-ai.github.io/langgraph/)
- [Pydantic 문서](https://docs.pydantic.dev/)
- [TypedDict 문서](https://docs.python.org/3/library/typing.html#typing.TypedDict)

---

## 🚨 자주 발생하는 오류

### 1. `'dict' object has no attribute 'X'`
**원인**: TypedDict를 Pydantic처럼 접근  
**해결**: `state.X` → `state.get("X")` 또는 `state["X"]`

### 2. `Can receive only one value per step`
**원인**: 병렬 노드가 같은 필드 업데이트  
**해결**: `Annotated[list, operator.add]` 사용 또는 필드 분리

### 3. `KeyError: 'context_json'`
**원인**: 이전 노드가 실행 안되거나 에러 발생  
**해결**: `.get()` 사용 + None 체크

### 4. JSON serialization 오류
**원인**: Pydantic 객체를 직접 반환  
**해결**: `.dict()` 또는 `.model_dump()` 사용

---

## 💡 개발 워크플로우

1. **설계**: 어떤 데이터를 받고 반환할지 명확히
2. **스키마**: contracts에 필요한 스키마 정의
3. **구현**: Agent 함수 작성 (dict 반환!)
4. **테스트**: Jupyter에서 단위 테스트
5. **통합**: graph.py에 노드 등록
6. **검증**: 전체 그래프 실행 테스트
7. **최적화**: 성능 개선 및 에러 처리 강화

---

이 가이드를 프로젝트 루트에 두고 참고하세요!